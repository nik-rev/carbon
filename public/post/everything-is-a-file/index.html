<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">



<link rel="icon" type="image/ico" href="http://localhost:1313//favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313//favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313//favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="http://localhost:1313//android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313//apple-touch-icon.png">

<meta name="description" content=""/>

<title>
    
    Quest to understand the idea of &#34;Everything is a file&#34; | Nikita Revenco
    
</title>

<link rel="canonical" href="http://localhost:1313/post/everything-is-a-file/"/>

<meta property="og:url" content="http://localhost:1313/post/everything-is-a-file/">
  <meta property="og:site_name" content="Nikita Revenco">
  <meta property="og:title" content="Quest to understand the idea of &#34;Everything is a file&#34;">
  <meta property="og:description" content="I had been using Windows for most of my life. I didn’t know much about files – I thought that files are just what programs use to store their data (e.g. Notepad using .txt extension, Photoshop with its .psd, etc.)
I assumed that a file’s purpose is defined by its extension. And this conclusion made sense to me at the time, since for example I couldn’t open a .mp4 file format in Photoshop.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-09-22T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-09-22T00:00:00+00:00">













<link rel="stylesheet" href="/assets/combined.min.a904013acd8e3bd04ce56a64a8fe5525fd5f738ad6caa0bfbcbe39a8d7ed932d.css" media="all">





</head>







<body class="auto">

  <div class="content">
    <header>
      

<div class="header">

    

    <h1 class="header-title">
        <a href="http://localhost:1313/">Nikita Revenco</a>
    </h1>

    <div class="flex">
        

        
        
      
        <p class="small ">
            <a href="/" >
                /home
            </a>
        </p>
        
      
        <p class="small ">
            <a href="/posts" >
                /posts
            </a>
        </p>
        
      
        <p class="small ">
            <a href="/projects" >
                /projects
            </a>
        </p>
        
        
    </div>

    

</div>

    </header>

    <main class="main">
      





<div class="breadcrumbs">
    
    <a href="/">Home</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a href="/post/">Posts</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a class="breadcrumbs-current" href="/post/everything-is-a-file/">Quest to understand the idea of &#34;Everything is a file&#34;</a>
</div>



<div >

  <div class="single-intro-container">

    

    <h1 class="single-title">Quest to understand the idea of &#34;Everything is a file&#34;</h1>
    

    

    <p class="single-readtime">
      
      
      
      <time datetime="2024-09-22T00:00:00&#43;00:00">September 22, 2024</time>
      

      
    </p>

  </div>

  

  

  

  

  <div class="single-content">
    <p>I had been using Windows for most of my life. I didn&rsquo;t know much about files &ndash; I thought that files are just what programs use to store their data (e.g. Notepad using <code>.txt</code> extension, Photoshop with its <code>.psd</code>, etc.)</p>
<p>I assumed that a file&rsquo;s purpose is <em>defined by its extension</em>. And this conclusion made sense to me at the time, since for example I couldn&rsquo;t open a <code>.mp4</code> file format in Photoshop.</p>
<h2 class="heading" id="the-experiment">
  The Experiment
  <a href="#the-experiment">#</a>
</h2>
<p>When I started using Linux, I made an experiment. For example if I have just a single JavaScript <code>file.js</code> like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>console.log(<span style="color:#666;font-style:italic">&#34;Hello World!&#34;</span>);
</span></span></code></pre></div><p>Then running it with <code>node file.js</code> would output <code>Hello World!</code> in the terminal. But what confused me, was that when I tried to remove the extension completely:</p>
<pre tabindex="0"><code>console.log(&#34;Hello World!&#34;);
</code></pre><p>Running <code>node file</code> would still output the same string. So this was insightful to me, at this point I realised that the purpose of files is <strong>not</strong> defined by their extension &ndash; rather, its the <em>program itself</em> that decides how to read a specific file.</p>
<p>It seems that file extensions are only for semantic purposes. If I open a <code>file.js</code> in an IDE like <a href="https://code.visualstudio.com/">Visual Studio Code</a>, it&rsquo;ll know which highlighter to use, and that for example certain keywords like <code>import{:js}</code>, <code>const{:js}</code> should be highlighted. But the file extension (<code>.js</code>) isn&rsquo;t strictly required.</p>
<h3 class="heading" id="partitions">
  Partitions
  <a href="#partitions">#</a>
</h3>
<p>Okay, so that&rsquo;s interesting. But when I switched from Ubuntu to Arch Linux, I had to manually set up my partitions during the installation. For example a Windows <code>C:\</code> drive may be the equivalent to <code>/dev/sda</code> in Linux. And this <code>/dev/sda</code> may be divided into separate chunks called &ldquo;partitions&rdquo;, for example if we were to divide it into 3 partitions, we would have <code>/dev/sda1</code>, <code>/dev/sda2</code> and <code>/dev/sda3</code>.</p>
<p>Each of these partitions like <code>/dev/sda2</code> holds <em>very important information</em>, such as the file system to use (e.g. <a href="https://en.wikipedia.org/wiki/Ext4"><code>ext4</code></a>) and <strong>all of your data</strong>.</p>
<p>And at this point, I took notice at how <code>/dev/sda2</code> and others look like file paths. So I went exploring to see if that&rsquo;s actually the case&hellip;</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="font-weight:bold;font-style:italic">cd</span> /dev
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ls
</span></span></code></pre></div><p>There were a bunch of files listed, and to my surprise, I also noticed the three of my partitions, <strong><em>as files!</em></strong></p>
<pre tabindex="0"><code>sda1
sda2
sda3
</code></pre><p>I tried opening it with <code>nvim sda2</code>, thinking that I&rsquo;ll see a bunch of random data. But actually, it&rsquo;s empty?!</p>
<pre tabindex="0"><code class="language-sda2" data-lang="sda2"></code></pre><p>This was certainly odd, but I just guess the actual information is not being stored as text content and rather is embedded within the metadata, or something like that. Similar to how files don&rsquo;t contain the time they were modified as plain text, etc.</p>
<h3 class="heading" id="everything-is-a-file">
  Everything is a File
  <a href="#everything-is-a-file">#</a>
</h3>
<p>I was amazed to find out that so many things in Linux are files. I searched online and found out that it&rsquo;s in the unix philosophy that <a href="https://en.wikipedia.org/wiki/Everything_is_a_file">&ldquo;everything is a file&rdquo;</a>, but I didn&rsquo;t <em>really</em> believe it at first.</p>
<p>If that was true, if everything was a file &ndash; then to run those files we would need some sort of interpreter that can read files. But how would we have this interpreter, when the interpreter itself would have to be a file, so it would have to be an interpreter and&hellip;? This really sounds like a chicken-and-egg problem.</p>
<p>So this didn&rsquo;t really make much sense to me, I figured that the only way this could work is if we had a chain of interpreters which grow increasingly more complex. The 1st interpreter would have to be so simple that it can be directly read by the CPU, on &ldquo;raw metal&rdquo;, then we would gradually build up to something that can understand C to boot the kernel.</p>
<h2 class="heading" id="i-did-some-research">
  I Did Some Research
  <a href="#i-did-some-research">#</a>
</h2>
<p>As it turns out, files are simply abstractions of how data can be represented. In order for data to be stored, there has to be some sort of medium where two distinct states can be <em>read</em> and <em>manipulated</em> at will. For example:</p>
<ul>
<li><a href="https://simple.wikipedia.org/wiki/Hard_disk">Hard Disks</a> polarize each region with either north or south magnetization.</li>
<li><a href="https://simple.wikipedia.org/wiki/Compact_disc">CDs</a> use lasers that point at a surface, and the laser will either scatter or be reflected back.</li>
<li><a href="https://simple.wikipedia.org/wiki/Solid-state_drive">SSDs</a> store and release electrons from a tiny chamber.</li>
<li>Even DNA can store data by numbers to combinations of <a href="https://simple.wikipedia.org/wiki/DNA#Nucleotides">nucleotide bases</a>.</li>
</ul>
<h3 class="heading" id="file-systems">
  File Systems
  <a href="#file-systems">#</a>
</h3>
<p>Storing data is cool and all, but storing is in a way that makes sense is equally important. This is where <a href="https://simple.wikipedia.org/wiki/File_system">filesystems</a> come in to play.</p>
<p>Filesystems use bits of the storage media to hold data that doesn&rsquo;t belong to a specific file, but rather is there to organize them. Tables of where files start and end, metadata of files such as their names, permissions, etc.</p>
<p>At this point, the Operating System (<!-- raw HTML omitted -->OS<!-- raw HTML omitted -->) reads all that information and abstracts it away into an easy-to-digest format as folders and icons, it presents everything as if it was a file. Some things we see on the filesystems aren&rsquo;t files, they can be devices, network interfaces, etc. With this approach, we can access them by the same means as we would with an actual file.</p>
<h3 class="heading" id="bootstrapping">
  Bootstrapping
  <a href="#bootstrapping">#</a>
</h3>
<p>When the computer is first booted, there are no files. Just like there were no particles at the very beginning of the universe. The CPU has no idea what a file is, it can only read/write data from RAM and execute primitive instructions like adding two numbers and branching (jumping from one place to another based on some condition).</p>
<p>Once the CPU turns on it will run the instructions in some memory address, which contains the firmware (for example, <a href="https://simple.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a>).</p>
<p>The firmware instructs the CPU to load data from a given partition (like <code>/dev/sda2</code>), which is where our OS is stored.</p>
<p>At this point, Linux will copy the contents of a file which is the Initial RAM FileSystem (<a href="https://en.wikipedia.org/wiki/Initial_ramdisk"><code>initramfs</code></a>) &ndash; which contains an entire disk image of a bare-bones OS. This &ldquo;primitive&rdquo; OS is capable of stuff like reading filesystems, executing programs.</p>
<p>We use this basic OS to load our actual system that we&rsquo;ve installed on our disk. When our system is loaded, the primitive OS we first loaded gives up its control to our actual system and then <em>unloads itself from RAM</em>. 🥲</p>
<p>So we basically have:</p>
<ol>
<li>Computer turns on.</li>
<li>Firmware is turned on.</li>
<li>Data from boot partition is loaded and executed.</li>
<li>Primitive OS that can only perform basic tasks is loaded.</li>
<li>Our actual system is loaded by the primitive OS.</li>
</ol>
<p>Of course, we are really simplifying here &ndash; but it&rsquo;s nice to get a high level overview before <a href="https://en.wikipedia.org/wiki/Booting_process_of_Linux">delving deeper</a> if you are interested.</p>
<h3 class="heading" id="opening-binary-files">
  Opening Binary Files
  <a href="#opening-binary-files">#</a>
</h3>
<p>When I tried to open a binary file like <code>/bin/ls</code> (yes, even a command like <code>ls</code> is represented as a file) &ndash; all I would see is a bunch of gibberish:</p>
<pre tabindex="0"><code class="language-/bin/ls" data-lang="/bin/ls">ELF          &gt;    0Q      @       À         @ 
  @       @       @       Ø 
                       
   1I     1I            
               h                 h 
</code></pre><p>I was honestly expecting to see something like <code>001100110</code> &ndash; the raw binary data. But I don&rsquo;t&hellip; why is that?</p>
<p>Well, text editors may read each byte and translate them using ASCII into letters. But an image viewer may read groups of three bytes and convert each into a number between 0 and 255 indicating how much Red, Green and Blue for each pixel.</p>
<p>As we&rsquo;ve discovered earlier, purpose of files is defined by the reader, not the file extension! Let&rsquo;s say we had a pure binary file that contains the following binary data:</p>
<pre tabindex="0"><code>01001000 01100101 01101100 01101100
01101111 00100000 01010111 01101111
01110010 01101100 01100100
</code></pre><p>If we were to convert this to ascii, we would get <code>Hello World</code>, but if we were to interpret it as an image, we&rsquo;d convert this to hex first:</p>
<pre tabindex="0"><code>Row 1: [72, 101, 108, 108]
Row 2: [111, 32,  87, 111]
Row 3: [114, 108, 100, 0]
</code></pre><p>Converting it to an image where each each number represents the lightness value gives us:</p>
<!-- raw HTML omitted -->
<p>Interestingly enough though, we <em>can</em> actually see the raw bits of files with a tool like <a href="https://manpages.org/xxd"><code>xxd</code></a>! If we open up the <code>ls</code> command with <code>xxd /bin/ls</code> we will get over 8000+ lines of code, with some of it even marking sense! (<em>maybe</em>&hellip;)</p>
<pre tabindex="0"><code class="language-/bin/ls" data-lang="/bin/ls">00021250: 0000 0000 0000 0000 0000 0000 0000  ................
00021260: 0000 0000 0000 4034 0200 0000 0000  ........@4......
00021270: 0200 0000 0000 4743 433a 2028 474e  `&#34;......GCC: (GN
00021280: 2031 342e 322e 3120 3230 3234 3038  U) 14.2.1 202408
00021290: 0000 6c73 2e64 6562 7567 0000 0000  05..ls.debug....
000212a0: 8112 002e 7368 7374 7274 6162 002e  .z....shstrtab..
000212b0: 7465 7270 002e 6e6f 7465 2e67 6e75  interp..note.gnu
000212c0: 726f 7065 7274 7900 2e6e 6f74 652e  .property..note.
</code></pre><h3 class="heading" id="magic-numbers">
  Magic Numbers
  <a href="#magic-numbers">#</a>
</h3>
<p>While we found out that file extensions aren&rsquo;t really important, I also learned that many programs will use the first couple of bytes within a file to determine the file type and decide e.g. which highlighting engine to use.</p>
<p>Here&rsquo;s just some of those magic numbers and their corresponding file formats that I got from the <a href="https://en.wikipedia.org/wiki/List_of_file_signatures">list of file signatures</a>:</p>
<table>
  <thead>
      <tr>
          <th>Magic Number</th>
          <th>File Format</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>89 50 4E 47 0D 0A 1A 0A</code></td>
          <td><code>.png</code></td>
      </tr>
      <tr>
          <td><code>66 74 79 70 69 73 6F 6D</code></td>
          <td><code>.mp4</code></td>
      </tr>
      <tr>
          <td><code>25 50 44 46 2D</code></td>
          <td><code>.pdf</code></td>
      </tr>
  </tbody>
</table>
<h3 class="heading" id="references">
  References
  <a href="#references">#</a>
</h3>
<ul>
<li>Magic Numbers: <a href="https://en.wikipedia.org/wiki/File_format#Magic_number">https://en.wikipedia.org/wiki/File_format#Magic_number</a></li>
<li>List of Magic Number File Signatures: <a href="https://en.wikipedia.org/wiki/List_of_file_signatures">https://en.wikipedia.org/wiki/List_of_file_signatures</a></li>
<li>Everything is a File: <a href="https://en.wikipedia.org/wiki/Everything_is_a_file">https://en.wikipedia.org/wiki/Everything_is_a_file</a></li>
</ul>

    
  </div>

  


  

  
  

<div class="single-pagination">
    <hr />

    <div class="flex">

        <div class="single-pagination-prev">
            
            <div class="single-pagination-container-prev">
                <div class="single-pagination-text">←</div>
                <div class="single-pagination-text">
                    <a href="/post/useful-neovim-tricks/">
                        13 Neovim tips and life hacks that significantly improved my productivity
                    </a>
                </div>
            </div>
            
        </div>

        <div class="single-pagination-next">
            
            <div class="single-pagination-container-next">
                <div class="single-pagination-text">
                    <a href="/post/switched-to-nixos/">
                        I switched to NixOS from Arch Linux and I&#39;m never going back
                    </a>
                </div>
                <div class="single-pagination-text">→</div>
            </div>
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


    </main>
  </div>

  <footer>
     
 

  </footer>

  

</body>

<script>

  function isAuto() {
    return document.body.classList.contains("auto");
  }

  function setTheme() {
    if (!isAuto()) {
      return
    }

    document.body.classList.remove("auto");
    let cls = "light";
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      cls = "dark";
    }

    document.body.classList.add(cls);
  }

  function invertBody() {
    document.body.classList.toggle("dark");
    document.body.classList.toggle("light");
  }

  if (isAuto()) {
    window.matchMedia('(prefers-color-scheme: dark)').addListener(invertBody);
  }

  setTheme();

</script>

<script defer src="/js/copy-code.js"></script>
</html>